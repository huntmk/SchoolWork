This assignment and your previous assignment are about the data structures used at the two ends of the 3D graphics rendering pipeline; what goes into the beginning of the pipeline and what comes out of the end of the pipeline. Roughly, what goes into the pipeline is the Scene data structure which describes the geometry of what the renderer should draw. What comes out of the pipeline is the FrameBuffer data structure which holds the pixel image of the scene drawn by the renderer. The previous assignment was about just the FrameBuffer data structure. This assignment is about both what goes into the rendering pipeline, the Scene data structure and what comes out, the FrameBuffer data structure.

For this assignment, you will define three Model data structures that can be used to build scenes and then use your models to build a sequence of Scene data structures that can be given to the renderer to create a sequence of FrameBuffer data structures. You will then "post process" the pixels in the framebuffers to create a new sequence of framebuffers, and use the new sequence of framebuffers to create a movie. The post processing of the framebuffers will add a "special effect" that we would not be able to create using the renderer by itself.

As we have said in class, a Scene is mainly a collection of models. A Model is a list of vertices in 3-dimensional space (which we call "camera space") and a list of line segments. Each Vertex contains three doubles (for the x, y, and z coordinates of a point). Each LineSegment contains the (integer) index for two Vertex objects from the Model's vertex list. The vertices and line segments combine to form a "wireframe" shape that we see as a geometric object in the scene.

In the zip file that are three java source files, P.java, N.java, and W.java. Each of these files defines a sub-class of the Model class (from the scene package). The file P.java is complete. You need to complete the other two files so that each one defines a model that represents the letter of the alphabet the file is named after. You need to determine how many Vertex and LineSegment objects each model needs and then write the code that instantiates those objects and puts them into the model. These are two-dimensional models (all the vertices are in the xy-plane). Make each letter about one unit tall (in the y-direction), about one unit wide (in the x-direction).

If you want to see examples of Model classes, look at the files in the models package in renderer_2.zip. In particular, look at the files Square.java, Circle.java, Cube.java, and Tetrahedron.java, because those are the simplest models.

After you have defined your letter models, complete the program Hw2_v1.java that uses your letter models to create an animation that looks like the file Hw2_v1_animation.gif from the zip file (your letters do not have to look exactly like my letters). If we look at the letter P in the animation, it moves one unit up, then three units right and down, then one unit left, then one unit left and up, then two units left, and, finally, one unit right and up. This brings the P back to where it started (so the animation can cycle through the frames to create a continuous loop). In Hw2_v1.java the three letters have been pushed back into the z = -2 plane, and the view volume, in the z = -2 plane, extends from -2 to 2 along the x-axis, and from -2 to 2 along the y-axis.

After you have Hw2_v1.java creating the animation, complete Hw2_v2.java, which will add a "post processing" step to the animation frames to create an animation that looks like Hw2_v2_animation.gif from the zip file.

The main idea in Hw2_v2.java is that you will use a list of computed frames to produce a new frame that combines the list into a single frame showing a "tail" of motion. The method postProcess() will take in a List of FrameBuffer objects and return a new FrameBuffer object that is built using the pixel information in the list of frames. The list will hold the last twenty frames created by the renderer, and the return frame from postProcess() will be the frame that gets saved as a file for the final animation.

Another way to describe what Hw2_v2.java does is that it takes a moving "window" of 20 frames from the animation created by Hw2_v1.java and uses that 20 frame window to create one frame for Hw2_v2.java. As each Hw2_v2.java frame is created, one old frame from the "window" is dropped from the end of the "window" and a new (Hw2_v1.java) frame is placed at the beginning of the "window".

The file Hw2_v2.java contains an outline of the steps that you need to complete. Also, you can copy any needed code that you wrote for Hw2_v1.java into Hw2_v2.java.

After you have Hw2_v2.java working, convert the image frames that your program produces into a real "animation" file. To do this you need to download the following zip file and unzip it to your C:\ directory.
